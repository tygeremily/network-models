# -*- coding: utf-8 -*-
"""Network_Models.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UPaUew1q3klVBuwy-AsvRDgs-E7C5OrJ

# Network Models
"""

import networkx as nx
import matplotlib.pyplot as plt
import collections

# The following code will mount the drive
from google.colab import drive
drive.mount('/content/gdrive')

"""---
## Real-World Graph
"""

# File contains edgelist of a friendship network of users from music streaming service Deezer
G = nx.read_edgelist(path="/content/gdrive/My Drive/Github/RO_edges.csv", delimiter=',', nodetype=int)
num_edges = G.number_of_edges()
num_nodes = G.number_of_nodes()

# Return the number of nodes and edges from the real-world graph
print('number of nodes: {}, number of edges: {}'.format(num_nodes, num_edges))

"""#### Degree Distribtuion """

# The following function is used to generate the degree histogram of a given graph with the parameters G and title of the figure where G is the inputted graph
def plot_degree_histogram(G, title_of_figure):
    degree_sequence = sorted([d for n, d in G.degree()], reverse=True)  # degree sequence
    degreeCount = collections.Counter(degree_sequence)
    deg, cnt = zip(*degreeCount.items())
    fig, ax = plt.subplots()
    plt.bar(deg, cnt, width=0.80, color='b')
    plt.title("Degree Histogram of "+title_of_figure) #labels for graph and x,y axis 
    plt.ylabel("Count")
    plt.xlabel("Degree")
    ax.set_xticks([d + 0.4 for d in deg]) #increments for axis 
    ax.set_xticklabels(deg)
    plt.show(block=False)

    ## log-log scale
    fig, ax = plt.subplots()
    plt.loglog(deg, cnt,'ro-')
    plt.title("Log-Log Degree Histogram of "+title_of_figure)
    plt.ylabel("Log(Count)")
    plt.xlabel("Log(Degree)")
    plt.show(block=False)

# Call the function plot_degree_histogram to plot degree distribution for the real world model 
plot_degree_histogram(G, 'Real-World Model')

"""#### Average Clustering Coefficients

"""

# Call average_clustering function on G, the real world graph, to calculate average local clustering 
print('average clustering coefficients is {}'.format(nx.average_clustering(G)))

"""---
## Random Graph

"""

# Generate a random model using the function fast_gnp_random_graph with parameters n and p 
p = (2 * num_edges)  / (num_nodes * (num_nodes - 1)) # probability of forming an edge
gnp_graph = nx.fast_gnp_random_graph(n=num_nodes, p=p) #random graph

# Return number of nodes and edges of random to confirm same # of nodes and approximately same # of edges as G above
print('number of nodes: {}, number of edges: {}'.format(gnp_graph.number_of_nodes(), gnp_graph.number_of_edges()))

"""#### Degree Distribution

"""

# Call plot_degree_histogram to calculate the degree distribution of gnp_graph
plot_degree_histogram(G = gnp_graph, title_of_figure='Random Model')

"""#### Average Clustering Coefficient"""

# Call average_clustering function on gnp_graph to calculate average local clustering 
print('average clustering coefficients is {}'.format(nx.average_clustering(gnp_graph)))

"""---
## Small-World Model

"""

# Generate small-world model using the function watts_strogatz_graph with parameters n, p, and k 
# k should be an integer close to average degree of the real-world graph 
# p is the probability of rewiring each edge, using 0.45 for simplicity
average_degree = sum([d for n, d in G.degree()]) / num_nodes 
small_world = nx.watts_strogatz_graph(n=num_nodes, k=round(average_degree), p=0.45) #small-world graph

# Return number of nodes and edges of small-world to confirm same # of nodes and approximately same # of edges as G
print('number of nodes: {}, number of edges: {}'.format(small_world.number_of_nodes(), small_world.number_of_edges()))

"""#### Degree Distribution """

# Call plot_degree_histogram to calculate the degree distribution of small_world
plot_degree_histogram(G=small_world, title_of_figure='Small-World Model')

"""#### Average Clustering Coefficient"""

# Call average_clustering function on small_world to calculate average local clustering 
print('average clustering coefficients is {}'.format(nx.average_clustering(small_world)))

"""---
## Preferrential Attachment Model

"""

# Generate preferrential attachment graph using the function barabasi_albert_graph with parameters n, m, and optional seed 
# n is the # of nodes of the real world graph
# m is the number of edges to attach from a new node to an existing node 
preferential_attachment = nx.barabasi_albert_graph(n=num_nodes, m=round(num_edges / num_nodes)) #preferrential attachment graph

# Return number of nodes and edges of preferrential_attachment to confirm same # nodes and approximately same # of edges as G
print('number of nodes: {}, number of edges: {}'.format(preferential_attachment.number_of_nodes(), preferential_attachment.number_of_edges()))

"""#### Degree Distribution



"""

# Call the plot_degree_histogram to calculate the degree distribution for preferrential_attachment 
plot_degree_histogram(preferential_attachment, 'Preferential Attachment Model')

"""#### Average Clustering Coefficient"""

# Call average_clustering function on preferrential_attachment to calculate average local clustering 
print('average clustering coefficients is {}'.format(nx.average_clustering(preferential_attachment)))

"""## Summary of Degree Distributions"""

# Real-World Model
print('Degree for the real-world model is {}'.format(sum([d for n, d in G.degree()]) / num_nodes))

# Random Model
print('Degree for the random model is {}'.format(sum([d for n, d in gnp_graph.degree()]) / num_nodes))

# Small-World Model
print('Degree for the small-world model is {}'.format(sum([d for n, d in small_world.degree()]) / num_nodes))

# Preferential Attachment Model
print('Degree for the prefferential attachment model is {}'.format(sum([d for n, d in preferential_attachment.degree()]) / num_nodes))